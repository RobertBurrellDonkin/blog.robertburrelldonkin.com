---
title: Cheatsheet – Apache Kafka – Streams
slug: "/cheatsheets/kafka/streams"
---

# Key Qualities

 * **Scalability**
    * **topic-partition** distributed to **consumers** within a **consumer group**
    * capacity limited by
        * **partitioning**
        * **consumers**
    * **elasticity** within **limits**
        * **rebalancing** costs
 * **Reliability**
    * **consumer groups**
        * **fault tolerance** through **rebalancing**
    * **fault tolerance** for stateful operations on application-side
 * **Maintainability**
    * mature kafka ecosystem
    * deployment agnostic using application resources
    * **kappa** only, single model
    * **stream-relational**
 * **event-by-event** processing model
    * **no** microbatching
    * kafka achieves similar low latency, high throughput by higher parallelism
        * note **partitioning** therefore key
        * **depth-first**
            * **slow** processors block ingress
            * per **sub-topology**
            * factor blocking processing into separate **sub-topologies**
    * **kappa** architecture
        * **no** lambda
        * **not** hybrid
    * **stream-relational**
    * **dataflow programming** paradigm
    * topologies are **templates**
        * parallelized across **tasks** and **stream threads**
        * **stream threads** ```num.stream.threads```



# Properties

## Required

## Key
 * ```num.stream.threads```
    * increasing tasks per thread increases CPU utilitization
    * limited by cores
    * limited by task count
 * DEFAULT_DESERIALIZATION_EXCEPTION_HANDLER_CLASS_CONFIG
    * ```LogAndFailExceptionHandler```
    * ```LogAndContinueExceptionHandler```

# APIs
 * Start
    * ```new KafkaStreams(topology, config).start()```
        * non-blocking
        * spawns processing **stream threads**
 * Stop
    * ```streams.close()```
 * High level functional **DSL**
    * ```builder.stream(name).foreach((k,v)->...)```
 * Low level **Processor API**
    * ```topology.addSource(name, source)```
    * ```topology.addProcessor(name, processor)```
 * **Stream** data model
    * represents a **topic**
    * interested in history of values for **key**
        * within retention window
    * consumed from Kafka
    * ```KStream```
    * stream of **fact**
 * **Table** data model
    * also represents a **topic**
    * interested only in **latest** (highest offset) value for **key**
    * typically compacted topic ```cleanup.policy``` set to ```compact```
    * **stateful**
    * often used for **aggregations**
    * materialized using application-side key-value store
        * default **RocksDB**
    * built on the application side
    * ```KTable```
        * also represents a **topic**
        * **partitioned** following the topic
        * **distributed** by partition
        * **time synchronized**
    * ```GlobalKTable```
        * complete unpartitioned copy
        * high local overhead for large keyspaces
        * **not** time synchronized
            * joins always against the latest
    * behaviours
    * relationships between events
    * **stream-relational** snapshot of moving stream of facts
 * **Stream-Table Duality**
    * a stream might be reconstitute a table
    * table changes might be logged as a stream

# Operations
 * **Stateful**
    * ```Table``` views
    * typical use cases
        * **joining**
        * **aggregating**
        * **windowing**
    * topology includes **any** stateful operator

 * **Stateless**
    * ```Stream``` views **only**
    * no memory needed of previous events
    * topology includes **no** stateful operators

 * **Sinks**

## Sinks ###
 * ```to``` topology **terminator**
 * ```through``` **deprecated** **sub-topology**
 * ```repartition``` **sub-topology**

## Stateless
 * ```filter```
    * filter as early as possible to reduce wasted processing
 * ```filterNot```
    * syntactic sugar
    * improves readability
 * ```print```
 * ```branch```
 * ```map``` **re-keys**
 * ```mapValues``` **retains key**
    * more efficient than ```map``` unless **rekeying**
 * ```flatMap``` multiple outputs for each input **re-keys**
 * ```flatMapValues``` multiple outputs for each input **retains key**
    * more efficient than ```map``` unless **rekeying**
 * ```merge```

## Stateful
 * joins
    * ```join``` both sides share key
    * ```leftJoin``` when no match for left, right ```null```
    * ```outerJoin``` when no match, other side ```null```
 * aggregation
    * ```aggregate```
    * ```reduce```
    * ```count```
 * windowing
    * ```windowBy```

# State Stores

## Key Value Stores
 * as opposed to windowed stores
 * One application may contain many state stores
 * Types
    * **embedded** are internal and local associated with a task
        * colocation improves availability and reduces network traffic
        * fault tolerance through replay
            * **stand by*** aka **shadow** replicas reduce fault recovery time
        * high read availability through **stand by*** aka **shadow** replicas
        * **persistent** write to local disk
            * ```STATE_DIR_CONFIG``` default ```/tmp```
            * limited by disk, not memory, space
            * restored from disk, not rebuilt, potentially quicker recovery time
            * slower

## Windowed Stores

# Schemas

## Avro
 * **Generic records** when schema isn't available at runtime
 * **Specific records** generated from and include schema definition

## Schema Registry
 * Reduces message size by including ID for schema.
 * ```schema.registry.url```
 * ```AvroSerdes```