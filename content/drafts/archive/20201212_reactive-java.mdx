---
title: "Reactive Java"
date: 2021-12-12
tags:
 - java
 - reactive
 - concurrency
---

Tuning Java services has traditionally been something of a black art. If you are fortunate, you have someone already
initiated into the mysteries of bytecode, core flavouring, IO and GC. Quite often, back from the early 00s, I've
been the one turned to.

The Advanced Computer Science Masters at Manchester, the opened my eyes to the way hardware and software collaborate to
efficient process data (or not). The biggest

This is also the place I was first formally introduced to the advantage of non-blocking algorithms. Yes, helping to
maintain libraries in Apache Commons had inducted me into concurrency but ...

Many times especially . With elastic microservices, this has become even more important. When a Java microservice
uses blocking alogorithms, the parallel bandwidth is effectively limited not by network, memory or CPU but by threading.
Contemporary monitors are great for network, memory, IO and CPU but collecting context switching and threading metrics
is not something that's done routinely out of the box.

But devising non-blocking algorithms is non-trivial.

 * For engineers without specialist expertise (or a specialist language), mistakes are frequent
 * For engineers with specialist expertise, time and care are needed
 * Test automation tooling for non-blocking algorithms is not mature
 * Typical paradigms are not well-supported by IDEs
 * Static analysis methods are rarely taught to undergraduates.

And yes, Scala is a great language. And yes, for engineers with the right background in concurrency, Scala is far
more productive. But a language can be substitute for engineering expertise.

Which is why everyone is now so interested in reactive programming in Java.

It feels like Java.

But reactive microservices are limited by those familiar four horses – network, memory, IO and CPU – and can be scaled
elastically without inductions into the deeper mysteries.
